# 1. 협력하는 객체들의 공동체

### 객체 지향의 목표

- 실세계 모방 X
- 실세계 옮겨 담기 + 사용자를 만족시킬 수 있는 신세계 창조

### 실세계에 비유하는 이유

- 상태와 행위를 `캡슐화`하는 객체의 `자율성` 설명하기 효과적
- 객체는 `메시지`를 주고받으며 목표를 달성하기 위해 `협력`

## 협력하는 사람들

### 예시: 커피 가게

- 손님, 캐시어, 바리스타: `협력`하는 과정에서 각자의 `역할`에 `책임`
  - 손님: 주문
  - 캐시어: 주문 받음
  - 바리스타: 주문된 커피 제조
- 요청과 응답

    ```
        -주문->      -제조하라->
    손님        캐시어          바리스타
        <-커피-      <-커피-
    ```

### 역할과 책임

- 역할은 책임을 내포, 즉 특정 역할은 특정 책임 암시
- 특정한 역할을 맡는다는 사실이 의미하는 개념
  - 여러 사람이 동일한 역할 수행 가능
  - 역할은 대체 가능
  - 책임을 수행하는 방법은 자율적
  - 한 사람이 동시에 여러 역할 수행 가능
- 객체로 변환
  - 사람 => 객체
  - 요청 => 메시지
  - 처리 방법 => 메소드

## 협력 속에 사는 객체

- 역할, 책임, **협력**: 객체지향 어플리케이션 윤곽을 결정
- **객체**: 협력에 참여하는 주체
  - 메시지를 주고받으며 협력
- 기능 => 객체가 담당하기에 매우 복잡/거대
  - 객체끼리의 협력을 통해 기능 구현
- 객체의 덕목
    1. 객체는 협력적: 다른 객체의 요청에 응답
    1. 객체는 자율적: 스스로의 행위를 결정
        - 자율성 유지 위해 필요한 행동과 상태 지님
        - 외부에서 간섭 불가
        - 외부에서는 무엇을 하는지 알 수 있으나, 어떻게 하는지는 알 수 없음 => 캡슐화

## 객체지향의 본질

- 객체지향: 시스템을 상호작용하는 `자율적인 객체들의 공동체`ß로 바라보고 객체를 이용해 시스템을 분할하는 방법
- 자율적인 객체: `상태`, `행위`를 지니며 스스로를 책임짐
- 객체는 시스템의 구현을 위해 다른 객체와 `협력`, 정해진 `역할`을 수행하며 역할은 `책임`의 집합
- 객체는 다른 객체와 협력하기 위해 `메시지` 전송, 수신한 객체는 처리하는 데 적합한 `메서드`를 자율적으로 선택

# 2. 이상한 나라의 객체

## 객체지향과 인지 능력

- 인간은 다양한 객체들을 식별하고 분류함으로써 세상을 이해
- 추상적인 사물도 객체로 인식: 주문 내역, 계좌이체 등
- 소프트웨어에서의 객체는 세상의 객체를 모방했지만 전혀 다른 세계이다.

## 객체, 그리고 이상한 나라

### 엘리스 객체

- 병음료 마시거나 부채질 하거나 버섯 한 쪽 부분 먹으면 커짐
- 케이크, 버섯 반대 쪽 부분 먹으면 작아짐

### 행동과 상태

#### 행동: 상태 결정

- 키가 커짐, 작아짐

#### 상태: 행동의 결과 결정

- 키가 140에서 180이 됨
- 키가 150에서 190이 됨

### 엘리스의 특징

- 상태를 가지며 상태는 변경 가능
- 상태를 변경시키는 것은 행동
  - 행동의 결과는 상태의존적
  - 행동 순서가 결과에 영향
- 어떤 상태에 있더라도 유일하게 식별 가능

## 객체, 그리고 소프트웨어 나라

#### 객체

- 식별 가능한 개체 또는 사물
- 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상티 가짐
- 소프트웨어 안에서는 실행 가능한 코드로 구현

### 상태

#### 필요한 이유

- 객체의 반응은 이전까지 객체에 발생한 일에 따라 좌우
- 과거의 행동을 모두 기억하긴 어려워 상태라는 개념 창조
- 상태를 통해 결과를 쉽게 예측

#### 상태와 프로퍼티

- 숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓 등 단순한 값은 객체가 아님 => 다른 객체의 특성을 표현하는데 사용
- 객체를 사용해 객체의 상태를 표현해야할 때도 있음 => 객체 간의 연결로 표현
- property: 객체의 상태를 구성하는 모든 특징, 정적 `ex) 앨리스 - 들고있는 것, 키, 위치 등등`
  - property value: 시간의 흐름에 따라 변화 => 동적
  - link와 attribute로 구성
- link: 객체 간 의미 있는 연결, 다른 객체를 참조할 수 있음을 의미 `ex) 음료(150mL)를 들고있는 앨리스(180cm)`
  - 한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현
- attribute: 객체를 구성하는 단순한 값 (링크와 다름) `ex) 앨리스 키 180cm`
- 객체는 자율적 존재로 외부에서 상태에 직접적 접근/변경 불가 => 행동 이용

### 행동

#### 상태와 행동

- 객체의 행동에 의해 상태가 변경 => side effect
- 관계
  - 객체의 행동은 상태에 영향을 받는다. `ex) 키 180cm 앨리스는 작은 문을 통과하지 못한다.`
  - 객체의 행동은 상태를 변경시킨다. `ex) 앨리스가 독버섯을 먹고 키가 40cm 가 되었다.`
- 상태 관점에서 행동을 정의
  - 상호작용이 현재 상태에 어떤 방식으로 의존하는가 `ex) 엘리스 키가 40cm 이하라면 문을 통과할 수 있다.`
  - 상호작용이 어떻게 현재의 상태를 변경시키는가 `ex) 문을 통과한 후 앨리스의 위치는 아름다운 정원으로 바뀌어야 한다.`

#### 협력과 행동

- 자신에게 주어진 책임을 완료하기 위해 다른 객체를 이용 및 다른 객체에 서비스 제공
- 협력하기 위한 방법은 다른 객체에 메시지를 보내는 것 => 메시지 보내면 행동을 취할 수 있음
- 협력에 참여하는 과정에서 자신 및 다른 객체의 상태 변경을 유발할 수 있음
- 행동의 결과: 자신의 상태 변경, 다른 객체에 메시지 전송 `ex) 앨리스가 음료를 마신다 => 앨리스 키가 줄어든다, 메시지(음료의 양을 줄여라)`

#### 상태 캡슐화

- 현실세계에서는 능동적/수동적 존재가 나뉘지만 `ex) 앨리스(능동), 음료(수동)` 객체지향에서는 모두 자율적인 존재
- 요청은 하지만 요청 대상의 객체가 실제로 어떻게 상태를 변경하는지는 모름 + 해당 객체 자율적으로 결정
- 상태를 외부에 노출하지 않는 것은 객체의 자율성을 높임 => 지능도 높아짐 => 협력이 유연/간편

### 식별자

- 객체를 구분할 수 있는 property

#### 값 vs 객체: 식별자 여부

- value: 변하지 않는 양(immutable state), 두 상태가 같으면 같은 것으로 간주
  - 동등성(equality): 상태를 이용해 두 값이 같은지 판단할 수 있는 성질
  - 값 객체(value object)라고도 불림
- object: 변경되는 상태를 포함(mutable state), 상태가 같더라도 독립적인 별개의 객체로 다뤄야 함 `ex) 키가 같은 앨리스라는 이름의 두 사람`
  - 동일성(identical): 식별자 기반으로 판단할 수 있는 성질
  - 상태 기반으로 판별 할 수 없는 것은, 시간이 지남에 따라 객체 상태가 변하기 때문
  - 참조 객체(reference object), 엔티티(entity) 라고도 불림

## 기계로서의 객체

- 객체지향 창조하는 개발자들의 주된 업무
  - query: 객체 상태 조회
  - command: 객체 상태 변경
- 객체를 기계로 이해
  - 버튼 눌러 상태 조회
  - 버튼 눌러 행동

    ![image](https://user-images.githubusercontent.com/11757075/129476359-e721a7b4-5d6a-414e-9fa8-82f4106b183e.png)

## 행동이 상태를 결정한다

### 객체 지향 초보의 실수

- 상태 중심으로 객체 바라보기
  - 상태 결정 후 행위 결정

#### 나쁜 이유

1. 상태 먼저 결정 시 캡슐화 저해
    - 상태가 객체 내부로 캡슐화 되지 못하고 공용 인터페이스에 그대로 노출
1. 객체를 협력자가 아닌 고립된 섬으로 만듬
    - 협력을 고려하지 않고 설계하게 됨
1. 객체의 재사용성 저하
    - 협력에 참여하기 어렵기 때문에 재사용성 저하

#### 협력을 하기 위해선 행동에 초점을 맞추어야 함

### 책임-주도 설계 (Responsibility-Eriven Design, RDD)

- 응집도 높고 재사용 가능한 객체 설계 가능

## 은유와 객체

- 객체는 현실 세계의 모방이 아닌 현실을 참조한 새로운 세계의 창조이다.

### Anthropomorphism (의인화)

- 현실 객체 vs 소프트웨어 객체: 수동적 존재가 능동적 존재가 됨
- anthropomorphism(의인화): 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징

### Metaphor (은유)

- 한 가지 개념을 이용해 다른 개념을 서술
- 하나의 의미를 다른 것을 이용해 전달
- 프로그램 내의 객체는 현실 속의 객체에 대한 은유

#### 표현적 차이(representational gap), 의미적 차이(semantic gap)

- 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이
- 이 차이를 줄여 소프트웨어 구조를 쉽게 예측할 수 있음
- 은유를 효과적으로 사용 시, 이해하기 쉽고 유지보수가 용이한 소프트웨어 만들 수 있음

### 이상한 나라를 창조하라

- 이상한 나라의 앨리스에서 고양이는 말도 하고, 두발로 걷지만, "야옹" 이라고 한다는 것을 예측할 수 있음

# 3. 타입과 추상화

### 지하철 노선도

- 초기의 지하철 노선도: 역 연결 관계, 불필요한 지형 정보 혼합
- 현재의 지하철 노선도: 역 사이의 연결성에만 집중, 정확성을 버리고 목적에 집중한 결과
- 추상화하여 쉽고 단순하며 목적에 부합하는 지하철 노선도 창조

## 추상화를 통한 복잡성 극복

- 현실은 복잡: 증시, 날씨, 여자 친구가 화난 이유
- 현대의 지하철 노선도 쓰는 이유: 승객이 지하철을 바라보는 모델과 일치

### 추상화

- 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
- 추상화를 이루는 두 차원
  - 공통점을 취하고 차이점을 버리는 일반화
  - 중요한 부분 강조를 위해 불필요한 세부사항 제거

## 객체지향과 추상화

### 그룹으로 나누어 단순화하기

- 차이점을 무시하며 공통점만을 강조하며 그룹으로 나누기
- 세계에 내재된 복잡성을 효과적으로 감소

### Concept(개념)

- 공통점을 기반으로 객체들을 묶기 위한 그릇
- 개념을 이용하여 Classification(분류)할 수 있음
- Instance(인스턴스): 개념 그룹의 일원
- 객체: 특정한 개념을 적용할 수 있는 구체적인 사물
  - 개념이 객체에 적용됐을 때, 객체를 개념의 인스턴스라 함

### 개념의 세 가지 관점

- Symbol(심볼): 개념을 가리키는 이름/명칭
- Intension(내연): 개념의 완전한 정의, 객체가 개념에 속하는지 판별 가능
- Extension(외연): 개념에 속하는 모든 객체의 집합

#### class: 객체를 분류하기 위함

### 객체를 분류하기 위한 틀

- 분류: 객체에 특정한 개념을 적용하는 과정
  - 객체지향의 가장 중요한 개념 중 하나

### 분류는 추상화를 위한 도구

- 개념: 객체의 복잡성을 극복하기 위한 추상화 도구
- 추상화를 사용하므로써 복잡한 세상을 제어 가능한 수준으로 단순화할 수 있음

## 타입

### 타입은 개념

- type(타입): 개념과 동치

### 데이터 타입

- 모든 데이터는 bit string
- 데이터에 의미 부여 => type system이 생기기 시작
- type system: 데이터가 잘못 사용되지 않도록 제약사항 부과하는 것

#### 타입에 대한 조언

- 데이터가 어떳게 사용되느냐에 관한 것
  - 숫자형: 더하고 빼고 등등 가능
  - 문자열: 연결, 자르기 등 가능
  - 데이터의 타입 결정: 어떤 데이터에 어떤 연산자를 적용할 수 있냐
- 타입이 속한 데이터의 메모리에서의 표현 방식은 외부로부터 감춰짐

#### 메모리 안에 저장된 데이터 종류를 분류하는데 사용되는 메타데이터

### 객체와 타입

- 객체를 일종의 데이터처럼 사용
- 객체를 타입에 따라 분류하고, 타입에 이름 붙이는 것은 새로운 타입 선언과 같음
- 객체는 데이터인가? ㄴㄴ, 객체에서 중요한 것은 행동

#### 객체에 대한 조언

- 객체가 어떤 타입에 속하는지 결정하는 것은 객체가 수행하는 행동
- 객체의 내부적 표현은 외부로부터 감춰짐

### 객체지향 설계 중요원칙: 행동이 우선

- 객체가 동일한 행동 => 동일한 타입
- 객체의 타입을 결정하는건 객체의 행동
- 객체가 어떤 데이터를 보유하고있는지는 타입 결정에 영향 X

#### 다형성

- 같은 객체는 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식이 서로 다름 => 다형성
- 다형성: 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 것
- 동일한 메시지를 받을 수 있어야 하므로, 동일한 타입(타입 계층)에 속하게 됨

#### 캡슐화

- 외부에 행동만 제공하고 데이터를 감추는 것

## 타입의 계층

### 일반화/특수화 관계

- 더 일반적인/특수한 개념
- 일반화: 외연이 더 커짐
- 특수화: 객체가 외부에 제공하는 행동이 더 많아짐

### 슈퍼타입과 서브타입

- supertype: 일반적인 타입
- subtype: 특수한 타입, supertype을 대체 가능

### 일반화는 추상화를 위한 도구

## 정적 모델

### 타입의 목적

- 시간에 따라 동적으로 변하는 객체의 복잡성 극복
- `ex) 키 100cm 앨리스, 키 40cm 앨리스, ... => 키 속성을 가진 앨리스`

#### => 타입은 추상화

### 동적 모델과 정적 모델

- 객체지향 애플리케이션 설계/구현 시 아래와 같은 모델 적절히 혼용필요

#### 동적 모델: 살아움직이는 동안 상태가 어떻게 변하고 행동하는지 포착하는 것

    - snapshot, 객체 다이어그램 등으로도 불림

#### 정적 모델: 객체가 가질 수 있는 모든 상태와 행동을 시간에 독립적으로 표현하는 것

    - 타입 모델 등으로 불림

### 클래스

- 정적 모델의 구현
- 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나
- 코드를 재사용하는 용도로도 사용

#### 객체를 분류하는 기준은 타입, 타입을 나누는 기준은 행동

- 타입을 구현할 수 있는 한 가지 방법은 클래스

# 4. 역할, 책임, 협력

- 협력이라는 context가 객체의 행동 방식을 결정
- 초보자는 문맥을 고려하지 않은 채 객체가 가져야할 상태와 행동부터 고민하는 실수함

## 협력

- `협력`은 도움을 `요청`할 때 시작
- 요청 받은 사람은 일 처리 후 `응답`

### 재판 속의 협력

1. 누군가 왕에게 재판 `요청`
1. 왕이 토끼에게 증인 부를 것을 `요청`
1. 토끼는 모자장수를 증인으로 입장할 것을 `요청`
1. 모자장수는 증인석에 입장하여 토끼에게 `응답` 및 토끼도 왕에게 `응답`
1. 왕은 모자장수에게 증언 `요청`
1. 모자장수는 증언으로 `응답`

## 책임

- 어떤 `요청`에 응답해줄 수 있거나 적절한 행동을 할 의무가 있는 경우 `책임`을 가진다고 판단
- 객체지향에서 가장 중요한 능력은 책임을 능숙하게 객체에 할당하는 것

### 책임의 분류

#### 1. 하는 것(doing)

- 객체 생성, 계산 등 스스로 하는 것 `ex) 모자장수가 증인석에 입장`
- 다른 객체의 행동 시작시키는 것 `ex) 토끼가 모자장수를 증인석에 입장시킴`
- 다른 객체의 활동을 제어하고 조절하는 것 `ex) 왕이 목격자를 불러오도록 토끼에게 요청 및 모자장수에게 증언 요청`

#### 2. 아는 것(knowing)

- 개인적인 정보에 대해 아는 것
- 관련된 객체에 대해 아는 것 `ex) 토끼가 모자장수가 목격자인 것을 암`
- 자신이 유도하거나 계산할 수 있는 것에 대해 아는 것 `ex) 모자장수가 알고있는 것을 증언`

#### 공용 인터페이스 (public interface)

- 책임은 객체의 외부에 제공해 줄 수 있는 정보 및 서비스의 목록
- 책임은 객체의 공통 인터페이스를 구성

### 책임과 메시지

- 요청이 왔을 때만 책임을 수행
- 메시지 전송(message-send): 다른 객체에게 책임을 수행하도록 요청을 보내는 것
- 책임과 메시지 수준이 같지 않음
  - 책임: 객체가 협력에 참여하기 위해 수행해야하는 행위를 상위수준에서 개략적으로 서술한 것
  - 메시지: 협력을 정제하면서 책임을 여러 메시지로 분할
- 객체지향 설계: 어떤 객체가 어떤 책임을 수행해야하고 어떤 객체로부터 메시지를 수신할지 결정

## 역할

- 책임의 집합 == 협력 안에서 수행하는 역할
- 위의 재판의 예에서 왕은 여왕으로, 모자장수는 요리사 및 앨리스로 교체 가능
- 위의 3가지 협력을 따로 다루어야할까?

### 역할이 답이다

- 왕/여왕을 판사로, 모자장수/요리사/앨리스를 증인으로 `역할`을 사용하면 3가지 협력을 포괄하는 하나의 협력으로 추상화 가능

#### 역할 기반의 재판 속의 협력

1. 누군가 판사에게 재판 `요청`
1. 판사가 토끼에게 증인 부를 것을 `요청`
1. 판사는 증인이 입장할 것을 `요청`
1. 증인은 증인석에 입장하여 토끼에게 `응답` 및 토끼도 판사에게 `응답`
1. 판사는 증인에게 증언 `요청`
1. 증인은 증언으로 `응답`

#### 역할의 효과

- 추상화를 통한 인지 과부하 줄임
- 여러 객체의 협력 참여로 협력 유연화 및 재사용성 올라감
- 객체지향 설계의 단순성(simplicity), 유연성(flexibility), 재사용성(reusability)을 뒷받침함

#### 1. 협력의 추상화

- 구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력

#### 2. 대체가능성

- 역할 대체를 위해서는 행동이 호환되어야 함
- 객체는 주어진 책임 외에 다른 책임을 수행할 수도 있음 => 객체의 타입과 역할 사이에는 일반화/특수화 관계 성립
- 역할의 대체 가능성은 행위 호환성 의미, 행위 호환성은 동일한 책임의 수행 의미

## 객체의 모양을 결정하는 협력

### 흔한 오류

1. 데이터를 저장하기 위해 객체가 존재한다는 선입견
    - 데이터는 객체가 행위를 수행하는데 필요한 재료
1. 객체지향이 클래스간의 관계를 표현하는 정적인 측면에 중심
    - 중요한 것은 동적인 객체
    - 클래스는 시스템에 필요한 객체를 표현/생성하기 위한 구현 메커니즘

#### 객체를 설계하기 위해선 객체를 섬으로 보는 것이 아닌 협력 속에서 봐야 함

### 협력을 따라 흐르는 객체의 책임

- 협력을 설계한다는 것 => 객체들이 주고받을 요청과 응답의 흐름을 정의하는 것
- 책임(외부에 제공하게 될 행동) 및 필요한 데이터 결정 후 클래스의 구현 방법 결정

## 객체지향 설계 기법

### 책임-주도 설계: 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션 설계

1. 시스템의 책임 파악
1. 시스템의 책임을 더 작은 책임으로 분할
1. 분할된 책임을 수행할 수 있는 적적한 객체/역할을 찾아 책임 할당
1. 객체가 책임 수행 중 다른 객체의 도움이 필요할 경우, 이를 책임질 적절한 객체/역할을 찾음
1. 해당 객체/역할에 책임 할당함으로 두 객체가 협력하게 됨

### 디자인 패턴: 반복적으로 사용하는 해결 방법 정의해놓은 설계 템플릿 모음

- GOF(Gang of Four)가 제시
- ex) composite pattern

#### COMPOSITE pattern: 전체와 부분을 하나의 단위로 추상화해야하는 경우 사용

- `ex) 윈도우 탐색기의 파일 이동은 파일 이동 혹은 디렉토리/하위파일 이동 모두 지원, 사용자는 대상을 선택해서 경로를 바꾸면 됨`

### 테스트 주도 개발: 테스트를 구현하면서 애플리케이션 완성해나가는 방식, 역할/책임/협력을 식별하고 적합한지 피드백 받는 것

- 다양한 설계 경험과 패턴에 대한 지식이 없는 사람에게는 온전한 혜택을 누리기 어려움
- stub/mock객체 를 사용하는 것은 객체와 협력해야하는 협력자에 관해 고민한 결과를 표현한 것

# 5. 책임과 메시지

- 명확한 책임과 역할을 지닌 객체들이 협력에 참여해야 함

## 자율적인 책임

### 설계의 품질을 좌우하는 책임

- 객체는 기능 구현을 위해 협력하고, 협력 과정에서 책임을 위해 자율적으로 판단/행동
- 객체의 행동은 다른 객체의 요청을 수신했기 때문
- 적절한 책임을 적절한 객체에 할당해야 전체 설계의 방향이 결정 됨

### 자신의 의지에 따라 증언할 수 있는 자유

### 너무 추상적인 책임

- 포괄적이고 추상적인 책임이 무조건 좋은것은 아님
  - 너무 구체적: 책임 수행 방법 제한
  - 너무 추상적: 협력 의도 표현 힘듬
- 예시
  - 설명하라: 일생? 판매량? 존경하는 정도?
  - 증언하라: 적절한 책임
- 현재 문맥에서 가장 적합한 책임 선택 필요

### '어떻게'가 아니라 '무엇'을

- 자율적인 책임의 특징은 객체가 무엇을 해야하는가를 설명
  - 무엇: 중언한다.
  - 어떻게: 기억을 떠올려 + 시간 순서대로 재구성 + 간결하게 표현

### 책임을 자극하는 메시지

- 책임: 어떤 행동을 수행한다
- 메시지: 객체가 다른 객체에 접근할 수 있는 유일한 방법

## 메시지와 메서드

### 메시지

- 메시지의 구성
  - message name(메시지 이름): 전송하는 메시지를 가리키는 부분
  - argument(인자): 메시지 전송 시, 추가적인 정보
- 메시지 전송은 수신자와 메시지(메시지 이름, 인자)의 조합
  - 순서대로 나열하면 메시지 전송: `모자장수.증언하라(어제, 왕국)`
- 메시지를 수신받은 객체
  - 메시지 처리할 수 있는지 확인
  - 자신의 방식으로 처리 후 응답
- 메시지만 그대로이면 책임을 수행하는 방법을 변경해도 외부에서는 사실을 알 수 없음

### 메서드

- method(메서드): 메시지를 처리하기 위해 내부적으로 선택하는 방법
- 객체는 메시지를 수신하면, 처리할 수 있다고 판단 시 처리할 방법인 메서드 선택
- 객체가 runtime에 메서드를 선택할 수 있는 것은 객체지향 프로그래밍 언어의 특징

### 다형성

- 다형성: 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것
  - 서로 다른 타입의 객체들이 동일한 메시지 수신 => 다른 메서드를 이용해 메시지 처리할 수 있는 메커니즘
- 역할, 책임, 협력과 깊은 관련
  - 다형성 만족: 객체가 동일한 책임 공유
  - 송신자의 관점에서 다형적인 수신자들을 구별할 필요 없음
- 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미
  - 메서드는 달라져도 동일한 메시지 처리

### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

- 송신자 입장에서는 수신자가 메시지만 수신할 수 있다면 누가 되더라도 상관하지 않음
  - 즉, 수신자가 메시지를 이해할 수 있다는 사실만 알고 있는 상태에서 협력에 참여
- 적은 정보를 통한 상호 협력의 이점
  1. 협력이 유연해짐
  - 수신자가 메시지를 이해한다면 누구라도 상관하지 않음 (type 상관 안함)
  1. 협력이 수행되는 방식을 확장할 수 있음
    - 송신자에게 영향을 끼치지 않고 수신자 교체
  1. 협력이 수행되는 방식 재사용 가능

### 송신자와 수신자를 약하게 연결하는 메시지

## 메시지를 따라라

## 객체 인터페이스

## 인터페이스의 구현과 분리

## 책임의 자율성이 협력의 품질을 결정한다

# 6. 객체 지도

# 7. 함께 모으기

# 부록: 추상화 기법
