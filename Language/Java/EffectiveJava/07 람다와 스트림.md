# 람다와 스트림

- java8부터 람다와 스트림 api 추가되었음
- 람다: 함수 객체를 더 쉽게 만듬
- 스트림 api: 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원

## 42. 익명 클래스보다는 람다를 사용하라

- 익명 클래스는 너무 길어서 함수형 프로그램에 적합하지 않음
- interface들의 instance를 lambda expression으로 만들 수 있게 됨

### 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자

- lambda에서 매개변수와 반환값의 타입은 컴파일러가 추론함
- 가끔은 컴파일러가 결정하지 못할 때가 있고, 이때는 명시해주어야 함
- compiler가 type을 알 수 없다고 할 때만 해당 타입 명시하면 됨

### 람다는 이름이 없고 문서화도 못한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다

- 한줄 ~ 세줄 추천

### 익명 클래스를 대체할 수 없는 곳

#### lambda는 함수형 인터페이스에서만 쓰임

- 추상 클래스의 인스턴스를 만들 때에는 lambda를 쓰지 못하므로 익명 클래스를 써야 함

#### lambda는 자신을 참조할 수 없음

- `this` 키워드는 바깥 instance를 가리킴
- 자신을 참조해야할 때는 익명 클래스를 써야 함

### 람다를 직렬화하는 일은 극히 삼가야 한다

- 직렬화 형태가 구현 혹은 jvm 별로 다를 수 있음
- 필요하다면 (Comparator) private 정적 중첩 클래스의 instance 사용하라

## 43. 람다보다는 메서드 참조를 사용하라

- 람다가 익명 클래스보다 나은 점 중 가장 큰 특징은 **간결함**이다.
- method reference(메서드 참조)를 이용하면 더 간결해짐
- 람다로 할 수 없는 일은 메서드 참조로도 할 수 없음
  - 반례: 제네릭 함수 타입 구현

### 람다가 메서드 참조보다 간결할 때

- 메서드와 람다가 같은 클래스에 있을 때
  ```java
  service.execute(GoshThisClassNameIsHumongous::action);
  service.execute(() -> action());
  ```
- `Function.identity()`를 사용하는 경우
  ```java
  Function::identity;
  x->x;
  ```

### 메서드 참조 유형

#### 정적

- 정적 메서드 호출
- 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 동일
```java
Integer::parseInt;  // 메서드 참조
str -> Integer.parseInt(str); // 람다
```

#### 한정적

- 인스턴스의 method 이용
- 정적 참조와 비슷
- 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 동일
```java
Instant.now()::isAfter;  // 메서드 참조
Instant then = Instant.now();  // 람다를 위한 인스턴스 생성
t -> then.isAfter(t);  // 람다
```

#### 비한정적

- 함수 객체를 적용하는 시점에 수신 객체 알려줌
- 수신 객체: 메서드를 사용할 객체

```java
String::toLowerCase;  // 메서드 참조
str -> str.toLowerCaes();  // 람다
```

#### 클래스 생성자

- 클래스 생성자를 가리킴
```java
TreeMap<K,V>::new;  // 메서드 참조
() -> new TreeMap<K,V>()  // 람다
```

#### 배열 생성자

- 배열 생성자
```java
int[]::new;  // 메서드 참조
len -> new int[len];  // 람다
```

## 44. 표준 함수형 인터페이스를 사용하라

### 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라

- API가 다루는 개념의 수가 줄어들어 익히기 더 쉬워짐
- 표준 함수형 인터페이스들은 유용한 디폴트 메서드 많이 제공해 다른 코드와의 상호운용성이 좋아짐

#### `java.util.function` 패키지에서 기억할 6가지 interface

- Operator: 반환값과 인수의 type이 같음
  - UnaryOperator: 인수 1개
  - BinaryOperator: 인수 2개
- Predicate: 인수 하나를 받아 `boolean` 반환
- Function: 인수와 반환 타입이 다름
- Supplier: 인수를 받지 않고 값을 반환
- Consumer: 인수를 하나 받고 반환값은 없음

#### 각 기본 interface들에 대해 기본타입 3개씩 지원

- `int`, `long`, `double`
- interface 이름 앞에 type 붙이면 됨
  - `IntPredicate`, `LongBinaryOperator`
- Function 은 명시되는 type만 매개변수화 되고, 반환타입은 정해져있음

#### 기타 위에 언급된 interface들 변형을 통해 여러가지 사용 가능

### 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자

- `int` ㅇㅇ, `Integer` ㄴㄴ
- 계산량이 많을 때는 성능이 처참히 느려질 수 있다.

### 직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface` 애너테이션을 사용하라

- 해당 인터페이스가 람다용으로 설계된 것임을 알려줌
- 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해줌
- 유지보수 과정에서 실수로 메서드를 추가하지 못하게 막아줌

## 45. 스트림은 주의해서 사용하라

## 46. 스트림에서는 부작용 없는 함수를 사용하라

## 47. 반환 타입으로는 스트림보다 컬렉션이 낫다

## 48. 스트림 병렬화는 주의해서 적용하라
